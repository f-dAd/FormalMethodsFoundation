import unittest
from typing import List
import copy
from z3 import *

# In this problem, you will implement the DPLL algorithm as discussed
# in the class.


# a utility class to represent the code you should fill in.
class Todo(Exception):
    def __init__(self, msg):
        self.msg = msg

    def __str__(self):
        return self.msg

    def __repr__(self):
        return self.__str__()


########################################
# This bunch of code declare the syntax for the propositional logic, we
# repeat here:
'''
P ::= p
    | T
    | F
    | P /\ P
    | P \/ P
    | P -> P
    | ~P
'''


class Prop:
    def __repr__(self):
        return self.__str__()


class PropVar(Prop):
    def __init__(self, var):
        self.var = var

    def __str__(self):
        return self.var

    def __hash__(self):
        return hash(self.var)

    def __eq__(self, other):
        return other.__class__ == self.__class__ and self.var == other.var


class PropTrue(Prop):
    def __init__(self):
        pass

    def __str__(self):
        return "True"

    def __eq__(self, other):
        return other.__class__ == self.__class__


class PropFalse(Prop):
    def __init__(self):
        pass

    def __str__(self):
        return "False"

    def __eq__(self, other):
        return other.__class__ == self.__class__


class PropAnd(Prop):
    def __init__(self, left, right):
        self.left = left
        self.right = right

    def __str__(self):
        return f"({self.left} /\\ {self.right})"


class PropOr(Prop):
    def __init__(self, left, right):
        self.left = left
        self.right = right

    def __str__(self):
        return f"({self.left} \\/ {self.right})"


class PropImplies(Prop):
    def __init__(self, left, right):
        self.left = left
        self.right = right

    def __str__(self):
        return f"({self.left} -> {self.right})"


class PropNot(Prop):
    def __init__(self, p):
        self.p = p

    def __str__(self):
        return f"~{self.p}"


# we can convert the above defined syntax into Z3's representation, so
# that we can check it's validity easily:
def to_z3(prop):
    if isinstance(prop, PropVar):
        return Bool(prop.var)
    elif isinstance(prop, PropTrue):
        return True
    elif isinstance(prop, PropFalse):
        return False
    elif isinstance(prop, PropAnd):
        return And(to_z3(prop.left), to_z3(prop.right))
    elif isinstance(prop, PropOr):
        return Or(to_z3(prop.left), to_z3(prop.right))
    elif isinstance(prop, PropImplies):
        return Implies(to_z3(prop.left), to_z3(prop.right))
    else:
        return Not(to_z3(prop.p))


#####################
# TODO: please implement the nnf(), cnf() and dpll() algorithm, as discussed
# in the class.
def nnf(prop: Prop) -> Prop:
    if isinstance(prop, PropAnd):
        return PropAnd(nnf(prop.left), nnf(prop.right))
    elif isinstance(prop, PropOr):
        return PropOr(nnf(prop.left), nnf(prop.right))
    elif isinstance(prop, PropImplies):
        return PropOr(PropNot(nnf(prop.left)), nnf(prop.right))
    elif isinstance(prop, PropNot):
        if isinstance(prop.p, PropNot):
            return nnf(prop.p.p)
        elif isinstance(prop.p, PropAnd):
            return PropOr(nnf(PropNot(prop.p.left)), nnf(PropNot(prop.p.right)))
        elif isinstance(prop.p, PropOr):
            return PropAnd(nnf(PropNot(prop.p.left)), nnf(PropNot(prop.p.right)))

        return PropNot(nnf(prop.p))
    else:
        return prop


def is_atom(nnf_prop: Prop) -> bool:
    if isinstance(nnf_prop, PropOr) or isinstance(nnf_prop, PropAnd):
        return False
    return True


def cnf(nnf_prop: Prop) -> Prop:
    def cnf_d(left: Prop, right: Prop) -> Prop:
        if isinstance(left, PropAnd):
            return PropAnd(cnf_d(left.left, right), cnf_d(left.right, right))
        if isinstance(right, PropAnd):
            return PropAnd(cnf_d(left, right.left), cnf_d(left, right.right))

        return PropOr(left, right)

    if isinstance(nnf_prop, PropAnd):
        return PropAnd(nnf(nnf_prop.left), nnf(nnf_prop.right))
    elif isinstance(nnf_prop, PropOr):
        return cnf_d(nnf(nnf_prop.left), nnf(nnf_prop.right))
    else:
        return nnf_prop


def flatten(cnf_prop: Prop) -> List[List[Prop]]:
    """Flatten CNF Propositions to nested list structure .

    The CNF Propositions generated by `cnf` method is AST.
    This method can flatten the AST to a nested list of Props.
    For example: "((~p1 \\/ ~p3) /\\ (~p1 \\/ p4))" can be
    transfer to "[[~p1, ~p3], [~p1, p4]]".

    Parameters
    ----------
    cnf_prop : Prop
        CNF Propositions generated by `cnf` method.

    Returns
    -------
    List[List[Prop]
        A nested list of Props, first level lists are connected by `And`,
        and second level lists is connected by `Or`.

    """

    def get_atom_from_disjunction(prop: Prop) -> List[Prop]:
        if is_atom(prop):
            return [prop]

        if isinstance(prop, PropOr):
            return get_atom_from_disjunction(prop.left) + get_atom_from_disjunction(prop.right)

    if isinstance(cnf_prop, PropAnd):
        return flatten(cnf_prop.left) + flatten(cnf_prop.right)
    elif isinstance(cnf_prop, PropOr):
        return [get_atom_from_disjunction(cnf_prop)]
    elif is_atom(cnf_prop):
        return [[cnf_prop]]


def find_unit_prop(flatten_cnf: [[Prop]]):
    for item in flatten_cnf:
        if item.__len__() == 1:
            return True, item[0]
    return False, None


def not_conflict(flatten_cnf: [[Prop]], prop: Prop):
    if isinstance(prop, PropVar):
        p_name = prop.__repr__()
        np_name = '~' + prop.__repr__()
    else:
        p_name = prop.__repr__()[1:]
        np_name = prop.__repr__()

    has_p = False
    has_np = False

    for i in range(len(flatten_cnf)):
        if len(flatten_cnf[i]) == 1:
            if flatten_cnf[i][0].__repr__() == p_name:
                has_p = True
            elif flatten_cnf[i][0].__repr__() == np_name:
                has_np = True

    if has_p and has_np:
        return False
    else:
        return True


def simplify(flatten_cnf: [[Prop]], prop: Prop):
    if isinstance(prop, PropVar):
        p_name = prop.__repr__()
        np_name = '~' + prop.__repr__()
    else:
        p_name = prop.__repr__()[1:]
        np_name = prop.__repr__()

    for disconjuction in flatten_cnf:
        for p in disconjuction:
            if p.__repr__() == p_name or p.__repr__() == np_name:
                disconjuction.remove(p)
        if len(disconjuction) == 0:
            flatten_cnf.remove(disconjuction)

    return flatten_cnf


def dpll(prop: Prop) -> dict:
    flatten_cnf = flatten(cnf(nnf(prop)))
    solution = []

    def dpll_core(flatten_cnf: [[Prop]]) -> bool:
        if len(flatten_cnf) == 0:
            return True

        has_unit_prop, p = find_unit_prop(flatten_cnf)

        while has_unit_prop:
            if not_conflict(flatten_cnf, p):
                solution.append(p)
                flatten_cnf = simplify(flatten_cnf, p)
            else:
                return False
            has_unit_prop, p = find_unit_prop(flatten_cnf)

        if len(flatten_cnf) == 0:
            return True

        another_prop = flatten_cnf[0][0]
        print(another_prop)
        past_solution_len = len(solution)
        solution.append(another_prop)

        # 深拷贝
        past_flatten_cnf = copy.deepcopy(flatten_cnf)
        # 递归
        if dpll_core(simplify(past_flatten_cnf, another_prop)):
            return True
        else:
            del solution[past_solution_len:]
            if isinstance(another_prop, PropVar):
                temp_prop = PropNot(another_prop.__repr__())
            else:
                temp_prop = PropVar(another_prop.__repr__()[1:])

            solution.append(temp_prop)
            past_flatten_cnf = copy.deepcopy(flatten_cnf)
            return dpll_core(simplify(past_flatten_cnf, temp_prop))

    is_sat = dpll_core(flatten_cnf)
    print(solution)

    def transfer_dict(solution: []) -> dict:
        solution_dict = {}
        for prop in solution:
            if isinstance(prop, PropVar):
                prop_name = prop.__repr__()
                solution_dict[prop_name] = True
            else:
                prop_name = prop.__repr__()[1:]
                solution_dict[prop_name] = False

        return solution_dict

    if is_sat:
        solution_dict = transfer_dict(solution)
    else:
        return unsat

    return solution_dict


#####################
# test cases:
# p -> (q -> ~p)
test_prop_1 = PropImplies(PropVar('p'), PropImplies(PropVar('q'), PropVar('p')))

# ~((p1 \/ ~p2) /\ (p3 \/ ~p4))
test_prop_2 = PropNot(PropAnd(
    PropOr(PropVar("p1"), PropNot(PropVar("p2"))),
    PropOr(PropVar("p3"), PropNot(PropVar("p4")))
))


######################
class TestDpll(unittest.TestCase):

    def test_to_z3_1(self):
        self.assertEqual(str(to_z3(test_prop_1)), "Implies(p, Implies(q, p))")

    def test_to_z3_2(self):
        self.assertEqual(str(to_z3(test_prop_2)), "Not(And(Or(p1, Not(p2)), Or(p3, Not(p4))))")

    def test_nnf_1(self):
        self.assertEqual(str(nnf(test_prop_1)), "(~p \\/ (~q \\/ p))")

    def test_nnf_2(self):
        self.assertEqual(str(nnf(test_prop_2)), "((~p1 /\\ p2) \\/ (~p3 /\\ p4))")

    def test_cnf_1(self):
        self.assertEqual(str(cnf(nnf(test_prop_1))), "(~p \\/ (~q \\/ p))")

    def test_cnf_2(self):
        self.assertEqual(str(cnf(nnf(test_prop_2))),
                         "(((~p1 \\/ ~p3) /\\ (~p1 \\/ p4)) /\\ ((p2 \\/ ~p3) /\\ (p2 \\/ p4)))")

    def test_cnf_flatten_1(self):
        self.assertEqual(str(flatten(cnf(nnf(test_prop_1)))), "[[~p, ~q, p]]")

    def test_cnf_flatten_2(self):
        self.assertEqual(str(flatten(cnf(nnf(test_prop_2)))),
                         "[[~p1, ~p3], [~p1, p4], [p2, ~p3], [p2, p4]]")

    def test_dpll_1(self):
        s = Solver()
        res = dpll(test_prop_1)
        s.add(Not(Implies(res["p"], Implies(res["q"], res["p"]))))
        self.assertEqual(str(s.check()), "unsat")

    def test_dpll_2(self):
        s = Solver()
        res = dpll(test_prop_2)
        s.add(Not(Not(And(Or(res["p1"], Not(res["p2"])), Or(res["p3"], Not(res["p4"]))))))
        self.assertEqual(str(s.check()), "unsat")


if __name__ == '__main__':
    unittest.main()
